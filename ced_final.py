# -*- coding: utf-8 -*-
"""CED_Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14VOPNOO4ecnPu4VMFMWnpDaRx5RcJrXc
"""

#coding:utf-8
import streamlit as st
import numpy as np
import matplotlib.pyplot as plt
import cv2
from PIL import Image, ImageOps
#from google.colab.patches import cv2_imshow

#!wget https://raw.githubusercontent.com/thatcathatechat/digital-image-processing-course/main/media/Lena.png

st.header("Apply Canny Edge Detector on your image")
st.write("Choose any image and get output:")

t_sigma = float(st.text_input("Standard Deviation for Gaussian Filter", 1))
lowThresholdRatio = float(st.text_input("Enter Lowe Threshold Ratio", 0.05))
highThresholdRatio = float(st.text_input("Enter High Threshold Ratio", 0.15))
# user_input = st.text_input("label goes here", default_value_goes_here)
# user_input = st.text_input("label goes here", default_value_goes_here)
uploaded_file = st.file_uploader("Choose an image...", type=['jpg', 'png', 'jpeg'])

#img =cv2.imread("Lena.png",0)

def get_gaussian_kernel(size=5, sigma=1):
  x, y = np.mgrid[-size//2 + 1:size//2 + 1, -size//2 + 1:size//2 + 1]
  g = np.exp(-((x**2 + y**2)/(2.0*sigma**2)))
  return g/g.sum()


#Blurring an image in frequency domain using fourier transform and inverse fourier transform
def gaussian_filter(image, ksize = 5, nsig = 1):
    gimage = np.array(image)
    h = get_gaussian_kernel(ksize, nsig)
    h = np.fft.fft2(h, image.shape)

    gimage = np.fft.fft2(gimage)
    gimage = gimage * h
    gimage = np.fft.ifft2(gimage).real
    return gimage

def convolution(image, kernel):
    gimage = np.array(image)
    h = np.fft.fft2(kernel, image.shape)

    gimage = np.fft.fft2(gimage)
    gimage = gimage * h
    gimage = np.fft.ifft2(gimage).real
    return gimage

def GetsobelXYGrad(img):
  sobelX = [[-1,0,1],
            [-2,0,2],
            [-1,0,1]]

  sobelY = [[1,2,1],
            [0,0,0],
            [-1,-2,-1]]

  Gx = convolution(img,sobelX)
  Gy = convolution(img,sobelY)
  Gxy = (Gx**2 + Gy**2)**(0.5)
  Gxy = Gxy / Gxy.max()
  Gxy = Gxy *255
  return Gxy,np.arctan2(Gy, Gx +0.000000000001)



def nonMaximaSuppression(mag,grad):
  
  nms = np.zeros(mag.shape)
  grad = np.rad2deg(grad) + 180 
  m, n = mag.shape[0], mag.shape[1]
  # print(np.rad2deg(direct)+180)
  for i in range(1, m-1):
    for j in range(1, n-1):

        val1 = 255
        val2 = 255
        angle = grad[i][j]
        if (angle >= 112.5 and angle <= 157.5) or (angle >= 292.5 and angle <= 337.5):
          # 135 degree gradient
          val1 = mag[i-1][j-1] # upper left pixel
          val2  = mag[i+1][j+1] # lower right left
        elif (angle >= 22.5 and angle <= 67.5) or (angle <= 202.5 and angle <= 247.5):
          # gradient in 45 degree angle
          val1 = mag[i-1][j+1] # upper right
          val2  = mag[i+1][j-1] # lower left
        elif (angle >= 67.5 and angle <= 112.5) or (angle <= 247.5 and angle <= 292.5):
          # vertical gradient
          val1 = mag[i-1][j] # upper 
          val2  = mag[i+1][j] # lower
        else:  
          # horizontal gradient
          val1 = mag[i][j-1] # left pixel
          val2  = mag[i+1][j+1] # right left

        if mag[i][j] >= val1 and mag[i][j] >= val2:
            nms[i][j] = mag[i][j]
  return nms


def doubleThresholding(img,lowThresRatio = 0.05,highThresRatio = 0.10,weakVal = 50,strongVal=255):
  highThres = np.max(img) * highThresRatio
  lowThres = highThres * lowThresRatio 
  out = np.zeros(img.shape)
  out[np.where((img > lowThres) & (img <= highThres))] = weakVal
  out[np.where(img >= highThres)] = strongVal 
  return out

def hysteresis(img, weakVal = 50, strong=255):
    M, N = img.shape  
    for i in range(1, M-1):
        for j in range(1, N-1):
            if (img[i,j] == weakVal):
                try:
                    if ((img[i+1, j-1] == strong) or (img[i+1, j] == strong) or (img[i+1, j+1] == strong)
                        or (img[i, j-1] == strong) or (img[i, j+1] == strong)
                        or (img[i-1, j-1] == strong) or (img[i-1, j] == strong) or (img[i-1, j+1] == strong)):
                        img[i, j] = strong
                    else:
                        img[i, j] = 0
                except IndexError as e:
                    pass
    return img



if uploaded_file is not None:
  original_image = Image.open(uploaded_file)
  img = ImageOps.grayscale(original_image)
  img = np.asarray(img)

  gg = gaussian_filter(img,5,t_sigma)

  gc,grad = GetsobelXYGrad(gg)

  # cv2_imshow(gc)

  nmout = nonMaximaSuppression(gc,grad)

  # cv2_imshow(nmout)

  dout = doubleThresholding(nmout, lowThresholdRatio, highThresholdRatio)


  # np.unique(dout)

  hout = hysteresis(dout,50,255)
  

  cv2.imwrite('temp_final.png', hout)
  cv2.imwrite('temp_double.png', dout)
  cv2.imwrite('temp_input.png', img)
  cv2.imwrite('temp_sobel.png', gc)
  cv2.imwrite('temp_gauss.png', gg)
  cv2.imwrite('temp_nms.png', nmout)


  st.text("Original Image ")
  st.image('temp_input.png')
  st.text("Gaussian Output")
  st.image('temp_gauss.png')
  st.text("Sobel Output")
  st.image('temp_sobel.png')
  st.text("Non Maxima Suppression")
  st.image('temp_nms.png')
  st.text("Double Thresholding")
  st.image('temp_double.png')
  st.text("Final Output with Hysteresis")
  st.image('temp_final.png')
  

